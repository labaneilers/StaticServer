using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;

namespace StaticWwwHelpers
{
	/// <summary>
	/// Reads a manifest file generated by hashly, and exposes an API to
	/// lookup individual manifest entries by path.
	/// </summary>
	public class ManifestFile : IManifestFile
	{
		/// <summary>
		/// If specified, all virtual paths will be prepended with this virtual root directory
		/// </summary>
		public string RootVirtualDirectory { get; private set; }

		/// <summary>
		/// A pair of maps from the parsed manifest:
		/// 1. Map: Maps from the canonical virtual path to the manifest entry.
		/// 2. ReverseMap: Maps from the versioned virtual path to the manifest entry.
		/// </summary>
		private class InternalDataMap
		{
			/// <summary>
			/// Maps from the canonical virtual path to the manifest entry.
			/// </summary>
			public IDictionary<string, ManifestEntry> Map { get; private set; }

			/// <summary>
			/// Maps from the versioned virtual path to the manifest entry.
			/// </summary>
			public IDictionary<string, ManifestEntry> ReverseMap { get; private set; }

			public ManifestEntryTree Tree { get; private set; }

			/// <summary>
			/// The date on which the manifest was last modified (at the time it was parsed).
			/// </summary>
			public DateTime LastModified { get; private set; }

			/// <summary>
			/// Useful for unit testing.
			/// </summary>
			/// <param name="entries">A list of manifest entries</param>
			/// <param name="rootDirectory">A root directory to prepend to each entry (can be null)</param>
			public InternalDataMap(IEnumerable<ManifestEntry> entries, string rootDirectory)
				: this(BuildDictionary(entries, rootDirectory))
			{
			}

			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="manifestFilePhysicalPath">The physical path of the manifest file</param>
			/// <param name="rootDirectory">A root directory to prepend to each entry (can be null)</param>
			public InternalDataMap(string manifestFilePhysicalPath, string rootDirectory)
				: this(ParseManifest(manifestFilePhysicalPath, rootDirectory))
			{
				this.LastModified = File.GetLastWriteTime(manifestFilePhysicalPath);
			}

			/// <summary>
			/// The "workhorse" constructor.
			/// </summary>
			/// <param name="map">The parsed manifest</param>
			private InternalDataMap(IDictionary<string, ManifestEntry> map)
			{
				this.Map = map;
				this.ReverseMap = CreateReverseMap(this.Map.Values);
				this.Tree = ManifestEntryTree.Build(this.Map.Values);
			}

			/// <summary>
			/// Builds the internal manifest representation from a list of entries.
			/// This is a map of virtualPath to manifest entry.
			/// </summary>
			/// <param name="entries">A list of manifest entries</param>
			/// <param name="rootDirectory">A root directory to prepend to each entry (can be null)</param>
			private static IDictionary<string, ManifestEntry> BuildDictionary(IEnumerable<ManifestEntry> entries, string rootDirectory)
			{
				var map = new Dictionary<string, ManifestEntry>(StringComparer.OrdinalIgnoreCase);

				foreach (var entry in entries)
				{
					string path = Concat(rootDirectory, entry.Path);
					string versionedPath = Concat(rootDirectory, entry.VersionedPath);

					map.Add(path, new ManifestEntry(path, versionedPath));
				}

				return map;
			}

			/// <summary>
			/// Create a secondary map that is keyed by versionedPath instead of virtualPath.
			/// </summary>
			/// <param name="entries">A list of manifest entries</param>
			private static IDictionary<string, ManifestEntry> CreateReverseMap(IEnumerable<ManifestEntry> entries)
			{
				var reverseMap = new Dictionary<string, ManifestEntry>(StringComparer.OrdinalIgnoreCase);
				foreach (ManifestEntry entry in entries)
				{
					reverseMap.Add(entry.VersionedPath, entry);
				}

				return reverseMap;
			}

			/// <summary>
			/// Concatenates two strings, handles nulls.
			/// </summary>
			private static string Concat(string a, string b)
			{
				if (a == null)
				{
					return b;
				}

				if (b == null)
				{
					return a;
				}

				return a + b;
			}

			/// <summary>
			/// Given a manifest file, parses the manifest into its internal map structure.
			/// </summary>
			/// <param name="manifestFilePhysicalPath">The physical path of the manifest file.</param>
			/// <param name="rootDirectory">A root directory to prepend to each entry (can be null)</param>
			private static IDictionary<string, ManifestEntry> ParseManifest(string manifestFilePhysicalPath, string rootDirectory)
			{
				var map = new Dictionary<string, ManifestEntry>(StringComparer.OrdinalIgnoreCase);

				using (var file = File.Open(manifestFilePhysicalPath, FileMode.Open, FileAccess.Read, FileShare.Read))
				{
					using (var reader = new StreamReader(file))
					{
						string line;
						string header = null;
						while ((line = reader.ReadLine()) != null)
						{
							// The manifest starts with a header with column names
							if (header == null)
							{
								header = line;
								continue;
							}
							string[] parts = line.Split('\t');

							string key = Concat(rootDirectory, parts[0]);
							map.Add(key, new ManifestEntry(key, Concat(rootDirectory, parts[1])));
						}
					}
				}

				return map;
			}
		}
			
		/// <summary>
		/// A task pool to queue re-parsing of the manifest file when it changes.
		/// </summary>
		//private static readonly TaskPool<ManifestFile> _changedFilePool = new TaskPool<ManifestFile>(1, UpdateMapFromFileSystem);

		/// <summary>
		/// Regex to extract versionIds from versioned paths.
		/// </summary>
		private static readonly Regex _versionIdRegex = new Regex(@"\-hc([a-f0-9]{32})\.", RegexOptions.Compiled | RegexOptions.IgnoreCase);

		private InternalDataMap _map;
		private readonly string _manifestFilePhysicalPath;

		/// <summary>
		/// Creates a manifest file factory with the specified manifest file.
		/// A FileSystemWatcher is initialized to ensure the factory reloads the 
		/// manifest file should it change.
		/// </summary>
		internal ManifestFile(string manifestFilePhysicalPath)
			: this(manifestFilePhysicalPath, null, true)
		{
		}

		/// <summary>
		/// Creates a manifest file factory with the specified manifest file.
		/// A FileSystemWatcher is initialized to ensure the factory reloads the 
		/// manifest file should it change.
		/// </summary>
		/// <param name="manifestFilePhysicalPath">The physical path of the manifest file</param>
		/// <param name="rootVirtualDirectory">If specified, all paths in the manifest will be prepended with this virtual root</param>
		public ManifestFile(string manifestFilePhysicalPath, string rootVirtualDirectory)
			: this(manifestFilePhysicalPath, rootVirtualDirectory, true)
		{
		}

		/// <summary>
		/// Manual construction. Useful for unit testing.
		/// </summary>
		internal ManifestFile(IEnumerable<ManifestEntry> entries) 
			: this(entries, null)
		{
		}

		/// <summary>
		/// Manual construction. Useful for unit testing.
		/// </summary>
		/// <param name="entries">Manifest entries to add manually. Useful for unit testing.</param>
		/// <param name="rootVirtualDirectory">If specified, all paths in the manifest will be prepended with this virtual root</param>
		internal ManifestFile(IEnumerable<ManifestEntry> entries, string rootVirtualDirectory)
		{
			_map = new InternalDataMap(entries, rootVirtualDirectory);
			this.RootVirtualDirectory = rootVirtualDirectory;
		}

		/// <summary>
		/// This constructor is internal because there's no production use case for 
		/// not using a filewatcher. This may be useful for unit testing.
		/// </summary>
		/// <param name="manifestFilePhysicalPath">The physical path of the manifest file</param>
		/// <param name="rootVirtualDirectory">If specified, all paths in the manifest will be prepended with this virtual root</param>
		/// <param name="watchFile">If true, the manifest will automatically be reloaded when it changes.</param>
		internal ManifestFile(string manifestFilePhysicalPath, string rootVirtualDirectory, bool watchFile)
		{
			_manifestFilePhysicalPath = manifestFilePhysicalPath;
			this.RootVirtualDirectory = rootVirtualDirectory;

			this.UpdateMap();

			if (watchFile)
			{
				var fileSystemWatcher = new FileSystemWatcher(Path.GetDirectoryName(manifestFilePhysicalPath))
				{
					Filter = Path.GetFileName(manifestFilePhysicalPath),
					EnableRaisingEvents = true
				};

				fileSystemWatcher.Changed += _fileSystemWatcher_Changed;
				fileSystemWatcher.Created += _fileSystemWatcher_Changed;
			}
		}

		private void UpdateMap()
		{
			lock (this)
			{
				_map = new InternalDataMap(_manifestFilePhysicalPath, this.RootVirtualDirectory);
			}
		}

		#region FileSystem watching

		private void _fileSystemWatcher_Changed(object sender, FileSystemEventArgs e)
		{
			ThreadPool.QueueUserWorkItem(new WaitCallback(x => UpdateMapFromFileSystem((ManifestFile)x)), this);
		}

		private static void UpdateMapFromFileSystem(ManifestFile factory)
		{
			UpdateMapFromFileSystem(factory, 0);
		}

		private static readonly Random _random = new Random();

		private static void UpdateMapFromFileSystem(ManifestFile factory, int tries)
		{
			// This is running outside the .NET handler, and CANNOT EVER throw an exception,
			// lest the process crash.
			try
			{
				if (File.GetLastWriteTime(factory._manifestFilePhysicalPath) > factory._map.LastModified)
				{
					factory.UpdateMap();

					if (factory.Changed != null)
					{
						try
						{
							factory.Changed.Invoke(factory, new EventArgs());
						}
						catch (Exception ex)
						{
							Configuration.ErrorReporter.Log("General error", ex);
						}
					}
				}
			}
			catch (IOException ioex)
			{
				// If the file is being written, or otherwise locked, try again once every second for 5 seconds before failing.
				if (tries >= 5)
				{
					Configuration.ErrorReporter.Log("Could not read manifestFile: " + factory._manifestFilePhysicalPath, ioex);
				}
				else
				{
					Thread.Sleep(_random.Next(1000, 3000));
					UpdateMapFromFileSystem(factory, tries + 1);
				}
			}
			catch (Exception ex)
			{
				Configuration.ErrorReporter.Log("General error", ex);
			}
		}

		#endregion

		#region public static API


		/// <summary>
		/// Given a versioned (translated) path, extract the StaticFileVersionId embedded in the path
		/// </summary>
		public static Guid GetVersionFromPath(string versionedPath)
		{
			if (versionedPath != null)
			{
				Match match = _versionIdRegex.Match(versionedPath);
				if (match.Groups.Count > 1)
				{
					Guid versionId;
					if (Guid.TryParse(match.Groups[1].Value, out versionId))
					{
						return versionId;
					}
				}
			}

			return Guid.Empty;
		}

		#endregion

		#region public API

		public bool TryGetEntry(string virtualPath, out ManifestEntry entry)
		{
			if (string.IsNullOrEmpty(virtualPath))
			{
				throw new ArgumentNullException("virtualPath");
			}

			// If we already have a hashed path, do a lookup in a reverse map and see if it exists.
			if (_versionIdRegex.IsMatch(virtualPath))
			{
				return _map.ReverseMap.TryGetValue(virtualPath, out entry);
			}

			return _map.Map.TryGetValue(virtualPath, out entry);
		}

		/// <summary>
		/// Returns the last modified date of the manifest file
		/// </summary>
		public DateTime LastModified
		{
			get { return _map.LastModified; }
		}

		private static readonly ManifestEntry[] EMPTY_LIST = {};

		/// <summary>
		/// Gets all manifest files in the specified directory
		/// </summary>
		public IEnumerable<ManifestEntry> ListDirectory(string virtualPath, bool recursive)
		{
			if (string.IsNullOrEmpty(virtualPath))
			{
				throw new ArgumentNullException("virtualPath");
			}

			if (virtualPath == "/")
			{
				return _map.Map.Values;
			}

			ManifestEntryTree node = _map.Tree.GetNode(virtualPath);

			if (node == null)
			{
				return EMPTY_LIST;
			}

			return node.ListContents(recursive)
				.Where(x => x.ManifestEntry != null)
				.Select(x => x.ManifestEntry);
		}

		/// <summary>
		/// Returns true if there is at least one manifest entry in the specified virtual path
		/// </summary>
		public bool DirectoryExists(string virtualPath)
		{
			if (string.IsNullOrEmpty(virtualPath))
			{
				return false;
			}

			return _map.Tree.GetNode(virtualPath) != null;
		}

		/// <summary>
		/// Event which fires when the underlying manifest file is updated
		/// </summary>
		public event EventHandler<EventArgs> Changed;

		#endregion
	}
}